// Определение. Целое положительное число называется простым,
// если оно имеет ровно два различных натуральных делителя — единицу и самого себя.
// Единица простым числом не считается.
//
// Решето Эратосфена (англ. sieve of Eratosthenes) — алгоритм нахождения
// всех простых чисел от до N.
// Основная идея соответствует названию алгоритма: запишем ряд чисел
// 1,2,3,4,...N, а затем будем вычеркивать
// сначала числа, делящиеся на 2, кроме самого числа 2,
// потом числа, делящиеся на 3, кроме самого числа 3,
// с числами, делящимися на 4, ничего делать не будем — мы их уже вычёркивали,
// потом продолжим вычеркивать числа, делящиеся на 5, кроме самого числа 5,и так далее.
//  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
//  1  1  1  0  1  0  1  0  0  0  1  0  1  0  0  0  1  0  1  0  0  0  1  0  0  0  0  0  1
//             1         2         3         4         5         6         7
//    1234567890123456789012345678901234567890123456789012345678901234567890
// 2: 0101010101010101010101010101010101010101010101010101010101010101010
// 3: 001001001001001001001001001001001001001001001001001001001001001001001
// 5  0000100001000010000100001000010000100001000010000100001000010000100001
// 7  0000001000000100000010000001000000100000010000001000000100000010000001
// 11 0000000000100000000001000000000010000000000100000000001000000000100000
// S  0110101000101000100
//         Задание:
//   Найти наибольшее простое число, меньшее заданного N,
//   N вводится как параметр командной строки.
//   Дополнительное требование: экономить память.

unsigned char er[10000000];
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
      if (argc != 2)
      {
            printf("Нужен один параметр - N (верхняя граница простых чисел) \n");
            return 0;
      }

      long N;
      sscanf(argv[1], "%ld", &N); 

      unsigned char *er = (unsigned char *)malloc(sizeof(unsigned char) * (N + 1));
      if (er == NULL)
      {
            printf("Ошибка выделения памяти.\n");
            return 1;
      }

      
      for (long i = 0; i <= N; i++)
      {
            er[i] = 1;
      }

      er[0] = er[1] = 0; // 0 и 1 не являются простыми числами

      // Применяем решето Эратосфена
      for (long i = 2; i * i <= N; i++)
      {
            if (er[i] == 1)
            {
                  for (long j = i * i; j <= N; j += i)
                  {
                        er[j] = 0;
                  }
            }
      }

     
      long largest_prime = 0;
      for (long i = N; i >= 2; i--)
      {
            if (er[i] == 1)
            {
                  largest_prime = i;
                  break;
            }
      }

      printf("Наибольшее простое число, меньшее %ld: %ld\n", N, largest_prime);

      free(er); 

      return 0;
}